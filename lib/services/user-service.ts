/**
 * User Service
 *
 * Manages user-to-Plaid item mappings in the database.
 * Links Better Auth users to their connected bank accounts (Plaid items).
 * All Plaid access tokens are encrypted at rest using AES-256-GCM.
 */

import { eq, and, desc, inArray, sql } from 'drizzle-orm';
import { db } from '../db';
import { plaidItems } from '../db/schema';
import { EncryptionService } from './encryption-service';
import { logger } from './logger-service';

export interface PlaidItem {
  id: string;
  userId: string;
  itemId: string;
  accessToken: string; // Decrypted token
  institutionId: string | null;
  institutionName: string | null;
  status: string | null;
  errorCode: string | null;
  errorMessage: string | null;
  consentExpiresAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Service for managing user Plaid items
 */
export class UserService {
  /**
   * Save a Plaid item for a user
   *
   * @param userId - Better Auth user ID
   * @param itemId - Plaid item ID
   * @param accessToken - Plaid access token (will be encrypted before storage)
   * @param institutionId - Optional institution ID
   * @param institutionName - Optional institution name
   */
  public static async savePlaidItem(
    userId: string,
    itemId: string,
    accessToken: string,
    institutionId?: string,
    institutionName?: string
  ): Promise<PlaidItem> {
    // Encrypt the access token before storing
    const encryptedToken = EncryptionService.encrypt(accessToken);

    const [item] = await db
      .insert(plaidItems)
      .values({
        // id will be auto-generated by schema default
        userId,
        itemId,
        accessToken: encryptedToken,
        institutionId: institutionId || null,
        institutionName: institutionName || null,
        status: 'active', // Item is ready immediately after public token exchange
      })
      .onConflictDoUpdate({
        target: plaidItems.itemId, // itemId is unique
        set: {
          userId, // Update userId in case it changed
          accessToken: encryptedToken,
          institutionId: institutionId || null,
          institutionName: institutionName || null,
          // Keep existing status on conflict (don't overwrite active/error states)
        },
      })
      .returning();

    // Return item with decrypted token
    return {
      ...item,
      accessToken: EncryptionService.decrypt(item.accessToken),
    };
  }

  /**
   * Get Plaid items for a user (always excludes deleted and revoked items)
   *
   * @param userId - Better Auth user ID
   * @param activeOnly - If true, only return items with status 'active'.
   *                     If false, return pending, active, and error items.
   *                     Deleted and revoked items are ALWAYS excluded.
   *
   * NOTE: For plan limit enforcement, use countUserItems() instead which
   * only counts active and error items.
   */
  public static async getUserPlaidItems(
    userId: string,
    activeOnly: boolean = true
  ): Promise<PlaidItem[]> {
    const items = await db
      .select()
      .from(plaidItems)
      .where(
        activeOnly
          ? and(eq(plaidItems.userId, userId), eq(plaidItems.status, 'active'))
          : and(
              eq(plaidItems.userId, userId),
              inArray(plaidItems.status, ['pending', 'active', 'error'])
            )
      )
      .orderBy(desc(plaidItems.createdAt));

    // Decrypt access tokens
    return items.map(item => ({
      ...item,
      accessToken: EncryptionService.decrypt(item.accessToken),
    }));
  }

  /**
   * Count user items for plan limit enforcement
   * Includes active and error items (excludes deleted and revoked)
   *
   * Note: 'pending' status is deprecated - items are set to 'active' immediately
   * after token exchange since Plaid items are ready to use right away.
   */
  public static async countUserItems(userId: string): Promise<number> {
    const result = await db
      .select({ count: sql<number>`COUNT(*)` })
      .from(plaidItems)
      .where(
        and(
          eq(plaidItems.userId, userId),
          inArray(plaidItems.status, ['active', 'error'])
        )
      );

    return Number(result[0]?.count || 0);
  }

  /**
   * Get a specific Plaid item by item ID
   *
   * @param userId - Better Auth user ID (for security)
   * @param itemId - Plaid item ID
   */
  public static async getPlaidItem(
    userId: string,
    itemId: string
  ): Promise<PlaidItem | null> {
    const [item] = await db
      .select()
      .from(plaidItems)
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)))
      .limit(1);

    if (!item) return null;

    // Return item with decrypted token
    return {
      ...item,
      accessToken: EncryptionService.decrypt(item.accessToken),
    };
  }

  /**
   * Get all access tokens for a user's active items
   *
   * Useful for aggregating data across all connected accounts
   */
  public static async getUserAccessTokens(userId: string): Promise<string[]> {
    const items = await this.getUserPlaidItems(userId, true);
    return items.map(item => item.accessToken);
  }

  /**
   * Mark a Plaid item as having an error
   *
   * @param userId - Better Auth user ID
   * @param itemId - Plaid item ID
   * @param errorCode - Plaid error code
   */
  public static async markItemError(
    userId: string,
    itemId: string,
    errorCode: string,
    errorMessage?: string
  ): Promise<void> {
    console.log(`[UserService] Marking item ${itemId} as error with code: ${errorCode}`);
    await db
      .update(plaidItems)
      .set({
        status: 'error',
        errorCode: errorCode,
        errorMessage: errorMessage || null,
      })
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)));
  }

  /**
   * Mark a Plaid item as revoked (user disconnected)
   *
   * @param userId - Better Auth user ID
   * @param itemId - Plaid item ID
   */
  public static async revokeItem(userId: string, itemId: string): Promise<void> {
    await db
      .update(plaidItems)
      .set({
        status: 'revoked',
      })
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)));
  }

  /**
   * Delete a Plaid item completely
   *
   * Use sparingly - prefer revokeItem() for soft deletion
   */
  public static async deletePlaidItem(
    userId: string,
    itemId: string
  ): Promise<void> {
    await db
      .delete(plaidItems)
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)));
  }
}
